from constants import *
import pygame
import sudoku_generator
import sys


class Cell:

    def __init__(self, value, row, col,
                 screen):  # initializes the class, sets the sketch value to none, says that no cell is selected
        self.sketch_value = None
        self.value = value
        self.row = row
        self.col = col
        self.screen = screen
        self.selected = False

    def set_cell_value(self, value):  # changes the set value
        self.value = value

    def set_sketched_value(self, value):  # changes the sketched value
        self.sketch_value = value

    def draw(self, screen):  # draws the cell on the board
        if self.selected:
            print(self.row, self.col, f'value: {self.value}')
            if self.col == 0 and self.row == 0:
                pygame.draw.rect(screen, (255, 0, 0),  # draws the red rectangle if cell select
                                 pygame.Rect(self.col * CELL_SIZE,
                                             self.row * CELL_SIZE, CELL_SIZE, CELL_SIZE), 3)
            elif self.col == 0:
                pygame.draw.rect(screen, (255, 0, 0), # fixes red rectangle alignment to look nicer
                                 pygame.Rect(self.col * CELL_SIZE,
                                             self.row * CELL_SIZE + LINE_WIDTH // 2, CELL_SIZE, CELL_SIZE - 1), 3)
            elif self.row == 0:
                pygame.draw.rect(screen, (255, 0, 0),
                                 pygame.Rect(self.col * CELL_SIZE + LINE_WIDTH // 2,
                                             self.row * CELL_SIZE, CELL_SIZE, CELL_SIZE), 3)
            else:
                pygame.draw.rect(screen, (255, 0, 0),
                                 pygame.Rect(self.col * CELL_SIZE + LINE_WIDTH // 2,
                                             self.row * CELL_SIZE + LINE_WIDTH // 2,
                                             CELL_SIZE - 1, CELL_SIZE - 1), 3)
            self.selected = False
        if self.sketch_value is not None:  # checks if sketch value exists
            sketch_font = pygame.font.Font(None, 30)  # if sketch value does exist, then draws number
            sketch_render = sketch_font.render(str(self.sketch_value), True, SKETCH_COLOR)
            sketch_rect = sketch_render.get_rect(
                center=(CELL_SIZE * self.col + CELL_SIZE // 2 + LINE_WIDTH // 2 - 2 * CELL_SIZE // 6,
                        CELL_SIZE * self.row + CELL_SIZE // 2 + LINE_WIDTH // 2 - 1 * CELL_SIZE // 3))
            screen.blit(sketch_render, sketch_rect)

        if self.value != 0:
            num_font = pygame.font.Font(None, 80)  # if value is not a missing cell, draws number
            num_render = num_font.render(str(self.value), True, CROSS_COLOR)
            value_rect = num_render.get_rect(
                center=(CELL_SIZE * self.col + CELL_SIZE // 2 + LINE_WIDTH // 2,
                        CELL_SIZE * self.row + CELL_SIZE // 2 + LINE_WIDTH // 2))
            screen.blit(num_render, value_rect)


class Board:

    def __init__(self, width, height, screen,
                 difficulty='easy'):  # intializes the board class, and sets the board equal to the board generated by the generate sudoku function in sudoku_generator.py
        self.width = width
        self.height = height
        self.screen = screen
        self.difficulty = difficulty
        if difficulty == 'easy':
            missing_cells = 30
        elif difficulty == 'medium':
            missing_cells = 40
        elif difficulty == 'hard':
            missing_cells = 50
        self.board = sudoku_generator.generate_sudoku(9, missing_cells)
        self.original_board = self.board  # saving 2D reference board for reset_to_original() function
        self.cells = [[Cell(self.board[row][col], row, col, screen) for col in range(9)] for row in
                      range(9)]  # creates list of cell objects based on the 2D board

    def draw(self):
        screen.fill(BG_COLOR)  # draws bg color
        for i in range(1, 4):  # draws horizontal lines
            pygame.draw.line(self.screen, LINE_COLOR, (0, i * SQUARE_SIZE),
                             (WIDTH, i * SQUARE_SIZE), LINE_WIDTH)
        for j in range(1, 3):  # draws vertical lines
            pygame.draw.line(screen, LINE_COLOR, (j * SQUARE_SIZE, 0), (j * SQUARE_SIZE, HEIGHT - 50), LINE_WIDTH)
        for i in range(1, 9):  # draws cell lines
            pygame.draw.line(self.screen, LINE_COLOR, (0, i * CELL_SIZE),
                             (WIDTH, i * CELL_SIZE), CELL_WIDTH)
        for j in range(1, 9):
            pygame.draw.line(screen, LINE_COLOR, (j * CELL_SIZE, 0), (j * CELL_SIZE, HEIGHT - 50), CELL_WIDTH)
        for i in range(9):  # draws the cell values
            for j in range(9):
                self.cells[i][j].draw(self.screen)
        reset_button(screen)
        restart_button(screen)
        exit_button(screen)

    def select(self, row, col):
        self.cells[row][col].selected = True

    def click(self, x, y):  # interprets x and y coords into cells
        if y <= 600:
            row = int(y // CELL_SIZE)
            col = int(x // CELL_SIZE)
            return row, col
        return None

    def clear(self):  # changes the value in the cell to 0
        self.cells[row][col].set_cell_value(0)

    def sketch(self, value):  # sets a sketched value
        self.cells[row][col].set_sketched_value(value)

    def place_number(self, value):  # sets an actual value
        self.cells[row][col].set_cell_value(value)

    def reset_to_original(self):  # sets the board back to what it was originally
        self.cells = [[Cell(self.original_board[row][col], row, col, screen) for col in range(9)] for row in range(9)]

    def is_full(self):  # determines if the board is filled with numbers
        for i in range(9):
            for x in range(9):
                if self.board[i][x] == 0:
                    return False
        return True

    def update_board(self):  # updates the board with the newly input values for cells
        self.board = [[int(self.cells[row][col].value) for col in range(9)] for row in range(9)]

    def find_empty(self):  # finds an empty cell on the board and returns its value
        for row in range(9):
            for col in range(9):
                if self.cells[row][col].value == 0:
                    return row, col
        return None

    def check_board(
            self):  # checks if the board has the right values in each spot. if it does, it returns True and if not returns False.
        test = sudoku_generator.SudokuGenerator(9, 0)
        test.board = self.board
        for row in range(9):
            for col in range(9):
                num = test.board[row][col]
                if num == 0:
                    return False
                test.board[row][col] = None
                result = test.is_valid(row, col, num)
                if not result:
                    return False
                elif result:
                    test.board[row][col] = num
        return True


def draw_game_start(screen):  # this shows the title screen
    # Initialize title font
    start_title_font = pygame.font.Font(None, 70)
    button_font = pygame.font.Font(None, 70)
    # Color background
    screen.fill(BG_COLOR)
    img = pygame.image.load('sudoku.jpg')
    img = pygame.transform.scale(img, (WIDTH, HEIGHT))
    rect = img.get_rect()
    screen.blit(img, rect)
    # Initialize and draw title
    title_surface = start_title_font.render("Welcome to Sudoku", True, LINE_COLOR)
    title_rectangle = title_surface.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 200))
    screen.blit(title_surface, title_rectangle)

    # Initialize and draw message
    message_font = pygame.font.Font(None, 50)
    message_surface = message_font.render("Select Game Mode", True, LINE_COLOR)
    message_rectangle = message_surface.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 100))
    screen.blit(message_surface, message_rectangle)

    # Initialize buttons
    # Initialize text first
    easy_text = button_font.render("EASY", True, BUTTON_TEXT_COLOR)
    medium_text = button_font.render("MEDIUM", True, BUTTON_TEXT_COLOR)
    hard_text = button_font.render("HARD", True, BUTTON_TEXT_COLOR)

    # Initialize button background color and text
    easy_surface = pygame.Surface((easy_text.get_size()[0] + 20,
                                   easy_text.get_size()[1] + 20))
    easy_surface.fill(BUTTON_COLOR)
    easy_surface.blit(easy_text, (10, 10))
    medium_surface = pygame.Surface((medium_text.get_size()[0] + 20,
                                     medium_text.get_size()[1] + 20))
    medium_surface.fill(BUTTON_COLOR)
    medium_surface.blit(medium_text, (10, 10))
    hard_surface = pygame.Surface((hard_text.get_size()[0] + 20,
                                   hard_text.get_size()[1] + 20))
    hard_surface.fill(BUTTON_COLOR)
    hard_surface.blit(hard_text, (10, 10))
    # Initialize button rectangle
    easy_rectangle = easy_surface.get_rect(center=(WIDTH // 2 - 200, HEIGHT // 2 + 150))
    medium_rectangle = medium_surface.get_rect(center=(WIDTH // 2, HEIGHT // 2 + 150))
    hard_rectangle = hard_surface.get_rect(center=(WIDTH // 2 + 200, HEIGHT // 2 + 150))

    # Draw buttons
    screen.blit(easy_surface, easy_rectangle)
    screen.blit(medium_surface, medium_rectangle)
    screen.blit(hard_surface, hard_rectangle)
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                if easy_rectangle.collidepoint(event.pos):
                    difficulty = 'easy'
                    return difficulty  # If the mouse is on the start button, we can return to main
                elif medium_rectangle.collidepoint(event.pos):
                    difficulty = 'medium'
                    return difficulty
                elif hard_rectangle.collidepoint(event.pos):
                    difficulty = 'hard'
                    return difficulty
        pygame.display.update()


def reset_button(screen):  # this shows the reset button on the screen
    button_font = pygame.font.Font(None, 22)  # rendering font
    reset_render = button_font.render("RESET", True, CROSS_COLOR)  # rendering reset font
    rect1 = pygame.Rect(0, 0, 80, 35)
    rect1.centerx = WIDTH // 2
    rect1.centery = HEIGHT - (50 // 2)  # centering rectangle to the bottom 50 pixels
    pygame.draw.rect(screen, (BUTTON_COLOR), rect1)  # drawing button rectangle
    pygame.draw.rect(screen, (56, 56, 56), rect1, 3)  # drawing button border
    reset_rect = reset_render.get_rect()
    reset_rect.center = rect1.center  # centering text to the center of rectangle
    screen.blit(reset_render, reset_rect)  # drawing button text
    return rect1 # returns rectangle to be used for collidepoint function in main


def restart_button(screen):  # this shows the restart button on the screen
    button_font = pygame.font.Font(None, 22)
    restart_render = button_font.render("RESTART", True, CROSS_COLOR)
    rect1 = pygame.Rect(0, 0, 80, 35)
    rect1.centerx = WIDTH // 2 - 90
    rect1.centery = HEIGHT - (50 // 2)
    pygame.draw.rect(screen, (BUTTON_COLOR), rect1)
    pygame.draw.rect(screen, (56, 56, 56), rect1, 3)
    restart_rect = restart_render.get_rect()
    restart_rect.center = rect1.center
    screen.blit(restart_render, restart_rect)
    return rect1


def exit_button(screen):  # this shows the exit button on the screen
    button_font = pygame.font.Font(None, 22)
    exit_render = button_font.render("EXIT", True, CROSS_COLOR)
    rect1 = pygame.Rect(0, 0, 80, 35)
    rect1.centerx = WIDTH // 2 + 90
    rect1.centery = HEIGHT - (50 // 2)
    pygame.draw.rect(screen, (BUTTON_COLOR), rect1)
    pygame.draw.rect(screen, (56, 56, 56), rect1, 3)
    exit_rect = exit_render.get_rect(center=rect1.center)
    screen.blit(exit_render, exit_rect)
    return rect1


def draw_win_screen(screen, win):  # this shows the win screen and exits the game when the quit button is clicked.
    restart = False
    if win:  # checks win condition
        text = 'Game Won!'
        button = 'QUIT'
    else:
        text = 'Game Over!'
        button = 'RESTART'
    img = pygame.image.load('sudoku.jpg')  # loads custom sudoku image
    img = pygame.transform.scale(img, (WIDTH, HEIGHT))  # scales image to fit screen
    rect = img.get_rect()
    screen.blit(img, rect)  # draws custom sudoku image
    rect.center = (WIDTH // 2, HEIGHT // 2)
    black = (255, 255, 255)
    white = (0, 0, 0)
    font = pygame.font.SysFont('freesansbold', 80)  # rendering text
    text = font.render(text, True, white)
    textRect = text.get_rect()
    textRect.center = (WIDTH // 2, HEIGHT // 2 - 200)
    screen.blit(text, textRect)  # draws text on screen
    button_font = pygame.font.Font(None, 27)
    quit_render = button_font.render(button, True, CROSS_COLOR)
    orange = BUTTON_COLOR
    rect1 = pygame.Rect(0, 0, 100, 45)
    rect1.centerx = WIDTH // 2
    rect1.centery = HEIGHT // 2
    pygame.draw.rect(screen, orange, rect1)  # draws button rectangle
    quit_rect = quit_render.get_rect()
    quit_rect.center = rect1.center
    screen.blit(quit_render, quit_rect)  # draws quit button on screen
    pygame.display.update()  # updates the screen
    while not restart:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:  # checks if user clicked button
                if rect1.collidepoint(event.pos):
                    if win:
                        sys.exit()
                    else:
                        restart = True
                        break


if __name__ == '__main__':
    pygame.init()
    screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption('Sudoku')
    while True:
        difficulty = draw_game_start(screen)
        restart = False
        cell_select = False
        screen.fill(BG_COLOR)
        board = Board(WIDTH, HEIGHT, screen, difficulty)  # initializes board object
        board.draw()
        reset_rect = reset_button(screen)
        restart_rect = restart_button(screen)
        exit_rect = exit_button(screen)
        while not restart:  # while loop breaks if user wants to restart game
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = event.pos
                    if y <= 600:
                        row, col = (board.click(x, y))
                        board.select(row, col)
                        cell_select = True
                        board.draw()
                        pygame.display.update()
                    if reset_rect.collidepoint(x, y):  # if restart button clicked, game restarts
                        board.reset_to_original()
                        board.draw()
                        print('balls')
                    elif restart_rect.collidepoint(x, y):
                        restart = True
                        break
                    elif exit_rect.collidepoint(x, y):
                        sys.exit()

                if event.type == pygame.KEYDOWN and cell_select == True:
                    arrow_list = [pygame.K_UP, pygame.K_DOWN, pygame.K_LEFT,
                                  pygame.K_RIGHT]  # detects if arrows keys clicked
                    if event.key in arrow_list:
                        if arrow_list.index(
                                event.key) == 0:  # if arrows keys clicked, corresponding row or col decreases
                            if row != 0:  # prevents list index out of range error
                                row -= 1
                        elif arrow_list.index(event.key) == 1:
                            if row != 8:
                                row += 1
                        if arrow_list.index(event.key) == 2:
                            if col != 0:
                                col -= 1
                        elif arrow_list.index(event.key) == 3:
                            if col != 8:
                                col += 1
                    board.select(row, col)
                    board.draw()
                    if board.original_board[row][col] != 0:  # prevents user from editing pre-existing boxes
                        continue
                    if event.unicode.isnumeric():
                        if event.unicode != '0':
                            board.select(row, col)
                            board.sketch(event.unicode)
                            board.draw()
                    if event.key == 13:  # enter key press
                        if board.cells[row][col].sketch_value != None:
                            num = board.cells[row][col].sketch_value
                            board.place_number(num)
                            board.select(row, col)
                            board.update_board()
                            board.draw()
                            if board.is_full():
                                if board.check_board():  # checks if winner
                                    draw_win_screen(screen, True)
                                else:
                                    draw_win_screen(screen, False)
                                    restart = True
            pygame.display.update()
        continue  # restart the game
